// Konfigurasi API - Gunakan path relative untuk Netlify Functions
const API_BASE_URL = '/.netlify/functions';

// Fallback data jika database offline
const fallbackData = {
  students: [],
  contents: [],
  quizResults: []
};

// Enhanced API Service dengan fallback mechanism
class ApiService {
    static async request(endpoint, options = {}) {
        const url = `${API_BASE_URL}${endpoint}`;
        const config = {
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            },
            ...options
        };

        try {
            const response = await fetch(url, config);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('API request failed:', error);
            
            // Fallback ke localStorage untuk critical operations
            if (endpoint === '/database/data' && options.method === 'GET') {
                const localData = localStorage.getItem('appData');
                return localData ? JSON.parse(localData) : fallbackData;
            }
            
            throw error;
        }
    }

    // Students methods
    static async getStudents() {
        try {
            return await this.request('/database/students', { method: 'GET' });
        } catch (error) {
            // Fallback ke localStorage
            const localData = localStorage.getItem('appData');
            const data = localData ? JSON.parse(localData) : fallbackData;
            return data.students || [];
        }
    }

    static async createStudent(student) {
        try {
            const result = await this.request('/database/students', {
                method: 'POST',
                body: JSON.stringify(student)
            });
            
            // Update local storage
            this.updateLocalStorage('students', result);
            return result;
        } catch (error) {
            // Fallback: simpan di localStorage
            const localData = localStorage.getItem('appData');
            const data = localData ? JSON.parse(localData) : { ...fallbackData };
            
            if (!data.students.find(s => s.id === student.id)) {
                data.students.push({ ...student, createdAt: new Date().toISOString() });
                localStorage.setItem('appData', JSON.stringify(data));
            }
            
            return student;
        }
    }

    // Contents methods
    static async getContents(filters = {}) {
        try {
            const params = new URLSearchParams();
            Object.keys(filters).forEach(key => {
                if (filters[key]) params.append(key, filters[key]);
            });
            
            return await this.request(`/database/contents?${params}`);
        } catch (error) {
            // Fallback ke localStorage
            const localData = localStorage.getItem('appData');
            const data = localData ? JSON.parse(localData) : fallbackData;
            let contents = data.contents || [];
            
            // Apply filters
            if (filters.chapter) {
                contents = contents.filter(c => c.chapter_id == filters.chapter);
            }
            if (filters.section) {
                contents = contents.filter(c => c.section === filters.section);
            }
            
            return contents;
        }
    }

    static async createContent(content) {
        try {
            const result = await this.request('/database/contents', {
                method: 'POST',
                body: JSON.stringify(content)
            });
            
            // Update local storage
            this.updateLocalStorage('contents', result);
            return result;
        } catch (error) {
            // Fallback: simpan di localStorage
            const localData = localStorage.getItem('appData');
            const data = localData ? JSON.parse(localData) : { ...fallbackData };
            
            const newContent = {
                ...content,
                id: Date.now().toString(),
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            };
            
            data.contents.push(newContent);
            localStorage.setItem('appData', JSON.stringify(data));
            
            return newContent;
        }
    }

    static async deleteContent(contentId) {
        try {
            await this.request(`/database/contents/${contentId}`, {
                method: 'DELETE'
            });
            
            // Update local storage
            const localData = localStorage.getItem('appData');
            if (localData) {
                const data = JSON.parse(localData);
                data.contents = data.contents.filter(c => c.id !== contentId);
                localStorage.setItem('appData', JSON.stringify(data));
            }
            
            return { success: true };
        } catch (error) {
            // Fallback: hapus dari localStorage
            const localData = localStorage.getItem('appData');
            if (localData) {
                const data = JSON.parse(localData);
                data.contents = data.contents.filter(c => c.id !== contentId);
                localStorage.setItem('appData', JSON.stringify(data));
            }
            
            return { success: true };
        }
    }

    // Authentication
    static async teacherLogin(credentials) {
        return this.request('/auth/login', {
            method: 'POST',
            body: JSON.stringify(credentials)
        });
    }

    // Helper method untuk update localStorage
    static updateLocalStorage(type, newItem) {
        const localData = localStorage.getItem('appData');
        const data = localData ? JSON.parse(localData) : { ...fallbackData };
        
        if (type === 'students') {
            const existingIndex = data.students.findIndex(s => s.id === newItem.id);
            if (existingIndex >= 0) {
                data.students[existingIndex] = newItem;
            } else {
                data.students.push(newItem);
            }
        } else if (type === 'contents') {
            const existingIndex = data.contents.findIndex(c => c.id === newItem.id);
            if (existingIndex >= 0) {
                data.contents[existingIndex] = newItem;
            } else {
                data.contents.push(newItem);
            }
        }
        
        localStorage.setItem('appData', JSON.stringify(data));
    }
}
